{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\nvar Features;\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\nvar RenderStrategy;\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\nfunction render(_ref) {\n  var props = _ref.props,\n    slot = _ref.slot,\n    defaultTag = _ref.defaultTag,\n    features = _ref.features,\n    _ref$visible = _ref.visible,\n    visible = _ref$visible === void 0 ? true : _ref$visible,\n    name = _ref.name;\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n      isStatic = _props$static === void 0 ? false : _props$static,\n      rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n    var _props$unmount = props.unmount,\n      unmount = _props$unmount === void 0 ? true : _props$unmount,\n      _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n  return _render(props, slot, defaultTag, name);\n}\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n  if (slot === void 0) {\n    slot = {};\n  }\n  var _omit = omit(props, ['unmount', 'static']),\n    _omit$as = _omit.as,\n    Component = _omit$as === void 0 ? tag : _omit$as,\n    children = _omit.children,\n    _omit$refName = _omit.refName,\n    refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n    passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n      return cloneElement(resolvedChildren, Object.assign({},\n      // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n  var _loop = function _loop() {\n    var func = _step.value;\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n  return clone;\n}\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n  var clone = Object.assign({}, object);\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n  return clone;\n}\nexport { Features, RenderStrategy, forwardRefWithAs, render };","map":{"version":3,"sources":["/Users/prince.kumar/Documents/Niyo-Dev/Games/travel-wordle/truddle/node_modules/@headlessui/react/src/utils/render.ts"],"names":["Features","RenderStrategy","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","None","Static","isStatic","rest","unmount","strategy","Unmount","Hidden","match","hidden","style","display","tag","as","Component","children","refName","passThroughProps","omit","refRelatedProps","ref","undefined","resolvedChildren","className","Fragment","Object","keys","length","isValidElement","Array","isArray","Error","map","line","join","cloneElement","assign","mergeEventFunctions","compact","createElement","existingProps","functionsToMerge","clone","func","event","defaultPrevented","forwardRefWithAs","component","forwardRef","displayName","object","key","keysToOmit"],"mappings":"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","sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n"]},"metadata":{},"sourceType":"module"}