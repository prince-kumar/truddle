{"ast":null,"code":"import { disposables } from '../../../utils/disposables.esm.js';\nimport { once } from '../../../utils/once.esm.js';\nfunction addClasses(node) {\n  var _node$classList;\n  for (var _len = arguments.length, classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classes[_key - 1] = arguments[_key];\n  }\n  node && classes.length > 0 && (_node$classList = node.classList).add.apply(_node$classList, classes);\n}\nfunction removeClasses(node) {\n  var _node$classList2;\n  for (var _len2 = arguments.length, classes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classes[_key2 - 1] = arguments[_key2];\n  }\n  node && classes.length > 0 && (_node$classList2 = node.classList).remove.apply(_node$classList2, classes);\n}\nvar Reason;\n(function (Reason) {\n  Reason[\"Finished\"] = \"finished\";\n  Reason[\"Cancelled\"] = \"cancelled\";\n})(Reason || (Reason = {}));\nfunction waitForTransition(node, done) {\n  var d = disposables();\n  if (!node) return d.dispose; // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n\n  var _getComputedStyle = getComputedStyle(node),\n    transitionDuration = _getComputedStyle.transitionDuration,\n    transitionDelay = _getComputedStyle.transitionDelay;\n  var _map = [transitionDuration, transitionDelay].map(function (value) {\n      var _value$split$filter$m = value.split(',') // Remove falsy we can't work with\n        .filter(Boolean) // Values are returned as `0.3s` or `75ms`\n        .map(function (v) {\n          return v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000;\n        }).sort(function (a, z) {\n          return z - a;\n        }),\n        _value$split$filter$m2 = _value$split$filter$m[0],\n        resolvedValue = _value$split$filter$m2 === void 0 ? 0 : _value$split$filter$m2;\n      return resolvedValue;\n    }),\n    durationMs = _map[0],\n    delaysMs = _map[1]; // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n\n  if (durationMs !== 0) {\n    d.setTimeout(function () {\n      done(Reason.Finished);\n    }, durationMs + delaysMs);\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished);\n  } // If we get disposed before the timeout runs we should cleanup anyway\n\n  d.add(function () {\n    return done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\nfunction transition(node, base, from, to, entered, done) {\n  var d = disposables();\n  var _done = done !== undefined ? once(done) : function () {};\n  removeClasses.apply(void 0, [node].concat(entered));\n  addClasses.apply(void 0, [node].concat(base, from));\n  d.nextFrame(function () {\n    removeClasses.apply(void 0, [node].concat(from));\n    addClasses.apply(void 0, [node].concat(to));\n    d.add(waitForTransition(node, function (reason) {\n      removeClasses.apply(void 0, [node].concat(to, base));\n      addClasses.apply(void 0, [node].concat(entered));\n      return _done(reason);\n    }));\n  }); // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n\n  d.add(function () {\n    return removeClasses.apply(void 0, [node].concat(base, from, to, entered));\n  }); // When we get disposed early, than we should also call the done method but switch the reason.\n\n  d.add(function () {\n    return _done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\nexport { Reason, transition };","map":{"version":3,"sources":["/Users/prince.kumar/Documents/Niyo-Dev/Games/travel-wordle/word-master/node_modules/@headlessui/react/src/components/transitions/utils/transition.ts"],"names":["addClasses","node","classes","length","classList","add","removeClasses","remove","Reason","waitForTransition","done","d","disposables","dispose","transitionDuration","transitionDelay","getComputedStyle","durationMs","delaysMs","map","resolvedValue","split","filter","Boolean","v","includes","parseFloat","sort","a","z","setTimeout","Finished","Cancelled","transition","base","from","to","entered","_done","undefined","once","nextFrame","reason"],"mappings":";;AAGA,SAASA,UAAT,CAAoBC,IAApB,EAAA;;oCAA0CC,OAAAA,GAAAA,IAAAA,KAAAA,CAAAA,IAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,IAAAA,GAAAA,CAAAA,EAAAA,IAAAA,GAAAA,IAAAA,EAAAA,IAAAA,EAAAA,EAAAA;IAAAA,OAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,IAAAA,CAAAA;;EACxCD,IAAI,IAAIC,OAAO,CAACC,MAARD,GAAiB,CAAzBD,IAA8B,CAAA,eAAA,GAAA,IAAI,CAACG,SAAL,EAAeC,GAAf,CAAA,KAAA,CAAA,eAAA,EAAsBH,OAAtB,CAA9BD;AACD;AAED,SAASK,aAAT,CAAuBL,IAAvB,EAAA;;qCAA6CC,OAAAA,GAAAA,IAAAA,KAAAA,CAAAA,KAAAA,GAAAA,CAAAA,GAAAA,KAAAA,GAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,KAAAA,GAAAA,CAAAA,EAAAA,KAAAA,GAAAA,KAAAA,EAAAA,KAAAA,EAAAA,EAAAA;IAAAA,OAAAA,CAAAA,KAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,KAAAA,CAAAA;;EAC3CD,IAAI,IAAIC,OAAO,CAACC,MAARD,GAAiB,CAAzBD,IAA8B,CAAA,gBAAA,GAAA,IAAI,CAACG,SAAL,EAAeG,MAAf,CAAA,KAAA,CAAA,gBAAA,EAAyBL,OAAzB,CAA9BD;AACD;IAEWO,MAAAA;AAAZ,CAAA,UAAYA,MAAAA,EAAAA;EACVA,MAAAA,CAAAA,UAAAA,CAAAA,GAAAA,UAAAA;EACAA,MAAAA,CAAAA,WAAAA,CAAAA,GAAAA,WAAAA;AACD,CAHD,EAAYA,MAAM,KAANA,MAAM,GAAA,CAAA,CAAA,CAAlB,CAAA;AAKA,SAASC,iBAAT,CAA2BR,IAA3B,EAA8CS,IAA9C,EAAA;EACE,IAAIC,CAAC,GAAGC,WAAW,CAAA,CAAnB;EAEA,IAAI,CAACX,IAAL,EAAW,OAAOU,CAAC,CAACE,OAAT,CAAA,CAAA;;0BAGmCG,gBAAgB,CAACf,IAAD,CAAA;IAAxDa,kBAAAA,GAAAA,iBAAAA,CAAAA,kBAAAA;IAAoBC,eAAAA,GAAAA,iBAAAA,CAAAA,eAAAA;aAEG,CAACD,kBAAD,EAAqBC,eAArB,CAAA,CAAsCI,GAAtC,CAA0C,UAAA,KAAK,EAAA;kCAChD,KAAK,CAC5BE,KADuB,CACjB,GADiB,CAAA,CAAA;QAAA,CAGvBC,MAHuB,CAGhBC,OAHgB,CAAA,CAAA;QAAA,CAKvBJ,GALuB,CAKnB,UAAA,CAAC,EAAA;UAAA,OAAKK,CAAC,CAACC,QAAFD,CAAW,IAAXA,CAAAA,GAAmBE,UAAU,CAACF,CAAD,CAA7BA,GAAmCE,UAAU,CAACF,CAAD,CAAVE,GAAgB,IAAxD;QAAA,CALkB,CAAA,CAMvBC,IANuB,CAMlB,UAACC,CAAD,EAAIC,CAAJ,EAAA;UAAA,OAAUA,CAAC,GAAGD,CAAd;QAAA,CANkB,CAAA;;QAArBR,aAAAA,GAAAA,sBAAAA,KAAAA,KAAAA,CAAAA,GAAgB,CAAA,GAAA,sBAAA;MAQrB,OAAOA,aAAP;IACD,CAV4B,CAAA;IAAxBH,UAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA;IAAYC,QAAAA,GAAAA,IAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA;EAajB;EACA;EACA;EACA;;EACA,IAAID,UAAU,KAAK,CAAnB,EAAsB;IACpBN,CAAC,CAACmB,UAAFnB,CAAa,YAAA;MACXD,IAAI,CAACF,MAAM,CAACuB,QAAR,CAAJrB;IACD,CAFDC,EAEGM,UAAU,GAAGC,QAFhBP,CAAAA;EAGD,CAJD,MAIO;IACL;IACA;IACAD,IAAI,CAACF,MAAM,CAACuB,QAAR,CAAJrB;EACD,CAAA,CAAA;;EAGDC,CAAC,CAACN,GAAFM,CAAM,YAAA;IAAA,OAAMD,IAAI,CAACF,MAAM,CAACwB,SAAR,CAAV;EAAA,CAANrB,CAAAA;EAEA,OAAOA,CAAC,CAACE,OAAT;AACD;SAEeoB,UAAAA,CACdhC,IAAAA,EACAiC,IAAAA,EACAC,IAAAA,EACAC,EAAAA,EACAC,OAAAA,EACA3B,IAAAA,EAAAA;EAEA,IAAIC,CAAC,GAAGC,WAAW,CAAA,CAAnB;EACA,IAAI0B,KAAK,GAAG5B,IAAI,KAAK6B,SAAT7B,GAAqB8B,IAAI,CAAC9B,IAAD,CAAzBA,GAAkC,YAAA,CAAA,CAA9C;EAEAJ,aAAa,CAAA,KAAbA,CAAAA,KAAAA,CAAAA,EAAAA,CAAcL,IAAdK,CAAAA,CAAAA,MAAAA,CAAuB+B,OAAvB/B,CAAAA,CAAAA;EACAN,UAAU,CAAA,KAAVA,CAAAA,KAAAA,CAAAA,EAAAA,CAAWC,IAAXD,CAAAA,CAAAA,MAAAA,CAAoBkC,IAApBlC,EAA6BmC,IAA7BnC,CAAAA,CAAAA;EAEAW,CAAC,CAAC8B,SAAF9B,CAAY,YAAA;IACVL,aAAa,CAAA,KAAbA,CAAAA,KAAAA,CAAAA,EAAAA,CAAcL,IAAdK,CAAAA,CAAAA,MAAAA,CAAuB6B,IAAvB7B,CAAAA,CAAAA;IACAN,UAAU,CAAA,KAAVA,CAAAA,KAAAA,CAAAA,EAAAA,CAAWC,IAAXD,CAAAA,CAAAA,MAAAA,CAAoBoC,EAApBpC,CAAAA,CAAAA;IAEAW,CAAC,CAACN,GAAFM,CACEF,iBAAiB,CAACR,IAAD,EAAO,UAAA,MAAM,EAAA;MAC5BK,aAAa,CAAA,KAAbA,CAAAA,KAAAA,CAAAA,EAAAA,CAAcL,IAAdK,CAAAA,CAAAA,MAAAA,CAAuB8B,EAAvB9B,EAA8B4B,IAA9B5B,CAAAA,CAAAA;MACAN,UAAU,CAAA,KAAVA,CAAAA,KAAAA,CAAAA,EAAAA,CAAWC,IAAXD,CAAAA,CAAAA,MAAAA,CAAoBqC,OAApBrC,CAAAA,CAAAA;MACA,OAAOsC,KAAK,CAACI,MAAD,CAAZ;IACD,CAJgB,CADnB/B,CAAAA;EAOD,CAXDA,CAAAA,CAAAA,CAAAA;EAcA;EACA;EACA;;EACAA,CAAC,CAACN,GAAFM,CAAM,YAAA;IAAA,OAAML,aAAa,CAAA,KAAbA,CAAAA,KAAAA,CAAAA,EAAAA,CAAcL,IAAdK,CAAAA,CAAAA,MAAAA,CAAuB4B,IAAvB5B,EAAgC6B,IAAhC7B,EAAyC8B,EAAzC9B,EAAgD+B,OAAhD/B,CAAAA,CAAN;EAAA,CAANK,CAAAA,CAAAA,CAAAA;;EAGAA,CAAC,CAACN,GAAFM,CAAM,YAAA;IAAA,OAAM2B,KAAK,CAAC9B,MAAM,CAACwB,SAAR,CAAX;EAAA,CAANrB,CAAAA;EAEA,OAAOA,CAAC,CAACE,OAAT;AACD","sourcesContent":["import { once } from '../../../utils/once'\nimport { disposables } from '../../../utils/disposables'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nexport enum Reason {\n  Finished = 'finished',\n  Cancelled = 'cancelled',\n}\n\nfunction waitForTransition(node: HTMLElement, done: (reason: Reason) => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map(value => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map(v => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n  if (durationMs !== 0) {\n    d.setTimeout(() => {\n      done(Reason.Finished)\n    }, durationMs + delaysMs)\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished)\n  }\n\n  // If we get disposed before the timeout runs we should cleanup anyway\n  d.add(() => done(Reason.Cancelled))\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  base: string[],\n  from: string[],\n  to: string[],\n  entered: string[],\n  done?: (reason: Reason) => void\n) {\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  removeClasses(node, ...entered)\n  addClasses(node, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...from)\n    addClasses(node, ...to)\n\n    d.add(\n      waitForTransition(node, reason => {\n        removeClasses(node, ...to, ...base)\n        addClasses(node, ...entered)\n        return _done(reason)\n      })\n    )\n  })\n\n  // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n  d.add(() => removeClasses(node, ...base, ...from, ...to, ...entered))\n\n  // When we get disposed early, than we should also call the done method but switch the reason.\n  d.add(() => _done(Reason.Cancelled))\n\n  return d.dispose\n}\n"]},"metadata":{},"sourceType":"module"}