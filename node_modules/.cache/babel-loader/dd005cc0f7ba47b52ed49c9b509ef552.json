{"ast":null,"code":"import { match } from './match.esm.js';\n\n//  - https://stackoverflow.com/a/30753870\n\nvar focusableSelector = /*#__PURE__*/['[contentEditable=true]', '[tabindex]', 'a[href]', 'area[href]', 'button:not([disabled])', 'iframe', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])'].map(process.env.NODE_ENV === 'test' ?\n// TODO: Remove this once JSDOM fixes the issue where an element that is\n// \"hidden\" can be the document.activeElement, because this is not possible\n// in real browsers.\n// TODO: Remove this once JSDOM fixes the issue where an element that is\nfunction (selector) {\n  return selector + \":not([tabindex='-1']):not([style*='display: none'])\";\n} : function (selector) {\n  return selector + \":not([tabindex='-1'])\";\n}).join(',');\nvar Focus;\n(function (Focus) {\n  /** Focus the first non-disabled element */\n  Focus[Focus[\"First\"] = 1] = \"First\";\n  /** Focus the previous non-disabled element */\n\n  Focus[Focus[\"Previous\"] = 2] = \"Previous\";\n  /** Focus the next non-disabled element */\n\n  Focus[Focus[\"Next\"] = 4] = \"Next\";\n  /** Focus the last non-disabled element */\n\n  Focus[Focus[\"Last\"] = 8] = \"Last\";\n  /** Wrap tab around */\n\n  Focus[Focus[\"WrapAround\"] = 16] = \"WrapAround\";\n  /** Prevent scrolling the focusable elements into view */\n\n  Focus[Focus[\"NoScroll\"] = 32] = \"NoScroll\";\n})(Focus || (Focus = {}));\nvar FocusResult;\n(function (FocusResult) {\n  /** Something went wrong while trying to focus. */\n  FocusResult[FocusResult[\"Error\"] = 0] = \"Error\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n\n  FocusResult[FocusResult[\"Overflow\"] = 1] = \"Overflow\";\n  /** Focus was successful. */\n\n  FocusResult[FocusResult[\"Success\"] = 2] = \"Success\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n\n  FocusResult[FocusResult[\"Underflow\"] = 3] = \"Underflow\";\n})(FocusResult || (FocusResult = {}));\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"Previous\"] = -1] = \"Previous\";\n  Direction[Direction[\"Next\"] = 1] = \"Next\";\n})(Direction || (Direction = {}));\nfunction getFocusableElements(container) {\n  if (container === void 0) {\n    container = document.body;\n  }\n  if (container == null) return [];\n  return Array.from(container.querySelectorAll(focusableSelector));\n}\nvar FocusableMode;\n(function (FocusableMode) {\n  /** The element itself must be focusable. */\n  FocusableMode[FocusableMode[\"Strict\"] = 0] = \"Strict\";\n  /** The element should be inside of a focusable element. */\n\n  FocusableMode[FocusableMode[\"Loose\"] = 1] = \"Loose\";\n})(FocusableMode || (FocusableMode = {}));\nfunction isFocusableElement(element, mode) {\n  var _match;\n  if (mode === void 0) {\n    mode = FocusableMode.Strict;\n  }\n  if (element === document.body) return false;\n  return match(mode, (_match = {}, _match[FocusableMode.Strict] = function () {\n    return element.matches(focusableSelector);\n  }, _match[FocusableMode.Loose] = function () {\n    var next = element;\n    while (next !== null) {\n      if (next.matches(focusableSelector)) return true;\n      next = next.parentElement;\n    }\n    return false;\n  }, _match));\n}\nfunction focusElement(element) {\n  element == null ? void 0 : element.focus({\n    preventScroll: true\n  });\n}\nfunction focusIn(container, focus) {\n  var elements = Array.isArray(container) ? container : getFocusableElements(container);\n  var active = document.activeElement;\n  var direction = function () {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next;\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n  var startIndex = function () {\n    if (focus & Focus.First) return 0;\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1;\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1;\n    if (focus & Focus.Last) return elements.length - 1;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n  var focusOptions = focus & Focus.NoScroll ? {\n    preventScroll: true\n  } : {};\n  var offset = 0;\n  var total = elements.length;\n  var next = undefined;\n  do {\n    var _next;\n\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error;\n    var nextIdx = startIndex + offset;\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total;\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow;\n      if (nextIdx >= total) return FocusResult.Overflow;\n    }\n    next = elements[nextIdx]; // Try the focus the next element, might not work if it is \"hidden\" to the user.\n\n    (_next = next) == null ? void 0 : _next.focus(focusOptions); // Try the next one in line\n\n    offset += direction;\n  } while (next !== document.activeElement); // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0');\n  return FocusResult.Success;\n}\nexport { Focus, FocusResult, FocusableMode, focusElement, focusIn, getFocusableElements, isFocusableElement };","map":{"version":3,"sources":["/Users/prince.kumar/Documents/Niyo-Dev/Games/travel-wordle/word-master/node_modules/@headlessui/react/src/utils/focus-management.ts"],"names":["focusableSelector","map","env","NODE_ENV","selector","join","Focus","FocusResult","Direction","getFocusableElements","container","document","body","Array","from","querySelectorAll","FocusableMode","isFocusableElement","element","mode","Strict","match","matches","Loose","next","parentElement","focusElement","focus","preventScroll","focusIn","elements","isArray","active","activeElement","direction","First","Next","Previous","Last","Error","startIndex","Math","max","indexOf","length","focusOptions","NoScroll","offset","total","undefined","nextIdx","WrapAround","Underflow","Overflow","hasAttribute","setAttribute","Success"],"mappings":";;AAGA;;AACA,IAAIA,iBAAiB,GAAA,aAAG,CACtB,wBADsB,EAEtB,YAFsB,EAGtB,SAHsB,EAItB,YAJsB,EAKtB,wBALsB,EAMtB,QANsB,EAOtB,uBAPsB,EAQtB,wBARsB,EAStB,0BATsB,CAAA,CAWrBC,GAXqB,CAYpB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAAzB;AAAA;AAEI;AACA;AAFA;AAGA,UAAA,QAAQ,EAAA;EAAA,OAAOC,QAAP,GAAA,qDAAA;AAAA,CAJZ,GAKI,UAAA,QAAQ,EAAA;EAAA,OAAOA,QAAP,GAAA,uBAAA;AAAA,CAjBQ,CAAA,CAmBrBC,IAnBqB,CAmBhB,GAnBgB,CAAxB;IAqBYC,KAAAA;AAAZ,CAAA,UAAYA,KAAAA,EAAAA;EACV;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,OAAAA;EAEA;;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,UAAAA;EAEA;;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,MAAAA;EAEA;;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,MAAAA;EAEA;;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,YAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,YAAAA;EAEA;;EACAA,KAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,GAAAA,EAAAA,CAAAA,GAAAA,UAAAA;AACD,CAlBD,EAAYA,KAAK,KAALA,KAAK,GAAA,CAAA,CAAA,CAAjB,CAAA;IAoBYC,WAAAA;AAAZ,CAAA,UAAYA,WAAAA,EAAAA;EACV;EACAA,WAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,OAAAA;EAEA;;EACAA,WAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,UAAAA;EAEA;;EACAA,WAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA;EAEA;;EACAA,WAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,WAAAA;AACD,CAZD,EAAYA,WAAW,KAAXA,WAAW,GAAA,CAAA,CAAA,CAAvB,CAAA;AAcA,IAAKC,SAAL;AAAA,CAAA,UAAKA,SAAAA,EAAAA;EACHA,SAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,GAAAA,UAAAA;EACAA,SAAAA,CAAAA,SAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,MAAAA;AACD,CAHD,EAAKA,SAAS,KAATA,SAAS,GAAA,CAAA,CAAA,CAAd,CAAA;SAKgBC,oBAAAA,CAAqBC,SAAAA,EAAAA;MAAAA,SAAAA,KAAAA,KAAAA,CAAAA,EAAAA;IAAAA,SAAAA,GAAgCC,QAAQ,CAACC,IAAAA;;EAC5E,IAAIF,SAAS,IAAI,IAAjB,EAAuB,OAAO,EAAP;EACvB,OAAOG,KAAK,CAACC,IAAND,CAAWH,SAAS,CAACK,gBAAVL,CAAwCV,iBAAxCU,CAAXG,CAAP;AACD;IAEWG,aAAAA;AAAZ,CAAA,UAAYA,aAAAA,EAAAA;EACV;EACAA,aAAAA,CAAAA,aAAAA,CAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,QAAAA;EAEA;;EACAA,aAAAA,CAAAA,aAAAA,CAAAA,OAAAA,CAAAA,GAAAA,CAAAA,CAAAA,GAAAA,OAAAA;AACD,CAND,EAAYA,aAAa,KAAbA,aAAa,GAAA,CAAA,CAAA,CAAzB,CAAA;SAQgBC,kBAAAA,CACdC,OAAAA,EACAC,IAAAA,EAAAA;;MAAAA,IAAAA,KAAAA,KAAAA,CAAAA,EAAAA;IAAAA,IAAAA,GAAsBH,aAAa,CAACI,MAAAA;;EAEpC,IAAIF,OAAO,KAAKP,QAAQ,CAACC,IAAzB,EAA+B,OAAO,KAAP;EAE/B,OAAOS,KAAK,CAACF,IAAD,GAAA,MAAA,GAAA,CAAA,CAAA,EAAA,MAAA,CACTH,aAAa,CAACI,MADL,CAAA,GAAA,YAAA;IAER,OAAOF,OAAO,CAACI,OAARJ,CAAgBlB,iBAAhBkB,CAAP;EACD,CAHS,EAAA,MAAA,CAITF,aAAa,CAACO,KAJL,CAAA,GAAA,YAAA;IAKR,IAAIC,IAAI,GAAuBN,OAA/B;IAEA,OAAOM,IAAI,KAAK,IAAhB,EAAsB;MACpB,IAAIA,IAAI,CAACF,OAALE,CAAaxB,iBAAbwB,CAAJ,EAAqC,OAAO,IAAP;MACrCA,IAAI,GAAGA,IAAI,CAACC,aAAZD;IACD;IAED,OAAO,KAAP;EACD,CAbS,EAAA,MAAA,CAAA,CAAZ;AAeD;SAEeE,YAAAA,CAAaR,OAAAA,EAAAA;EAC3BA,OAAO,IAAA,IAAPA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAES,KAATT,CAAe;IAAEU,aAAa,EAAE;EAAjB,CAAfV,CAAAA;AACD;SAEeW,OAAAA,CAAQnB,SAAAA,EAAwCiB,KAAAA,EAAAA;EAC9D,IAAIG,QAAQ,GAAGjB,KAAK,CAACkB,OAANlB,CAAcH,SAAdG,CAAAA,GAA2BH,SAA3BG,GAAuCJ,oBAAoB,CAACC,SAAD,CAA1E;EACA,IAAIsB,MAAM,GAAGrB,QAAQ,CAACsB,aAAtB;EAEA,IAAIC,SAAS,GAAI,YAAA;IACf,IAAIP,KAAK,IAAIrB,KAAK,CAAC6B,KAAN7B,GAAcA,KAAK,CAAC8B,IAAxB,CAAT,EAAwC,OAAO5B,SAAS,CAAC4B,IAAjB;IACxC,IAAIT,KAAK,IAAIrB,KAAK,CAAC+B,QAAN/B,GAAiBA,KAAK,CAACgC,IAA3B,CAAT,EAA2C,OAAO9B,SAAS,CAAC6B,QAAjB;IAE3C,MAAM,IAAIE,KAAJ,CAAU,+DAAV,CAAN;EACD,CALe,CAAA,CAAhB;EAOA,IAAIC,UAAU,GAAI,YAAA;IAChB,IAAIb,KAAK,GAAGrB,KAAK,CAAC6B,KAAlB,EAAyB,OAAO,CAAP;IACzB,IAAIR,KAAK,GAAGrB,KAAK,CAAC+B,QAAlB,EAA4B,OAAOI,IAAI,CAACC,GAALD,CAAS,CAATA,EAAYX,QAAQ,CAACa,OAATb,CAAiBE,MAAjBF,CAAZW,CAAAA,GAAwC,CAA/C;IAC5B,IAAId,KAAK,GAAGrB,KAAK,CAAC8B,IAAlB,EAAwB,OAAOK,IAAI,CAACC,GAALD,CAAS,CAATA,EAAYX,QAAQ,CAACa,OAATb,CAAiBE,MAAjBF,CAAZW,CAAAA,GAAwC,CAA/C;IACxB,IAAId,KAAK,GAAGrB,KAAK,CAACgC,IAAlB,EAAwB,OAAOR,QAAQ,CAACc,MAATd,GAAkB,CAAzB;IAExB,MAAM,IAAIS,KAAJ,CAAU,+DAAV,CAAN;EACD,CAPgB,CAAA,CAAjB;EASA,IAAIM,YAAY,GAAG,KAAK,GAAGvC,KAAK,CAACwC,QAAd,GAAyB;IAAElB,aAAa,EAAE;EAAjB,CAAzB,GAAmD,CAAA,CAAtE;EAEA,IAAImB,MAAM,GAAG,CAAb;EACA,IAAIC,KAAK,GAAGlB,QAAQ,CAACc,MAArB;EACA,IAAIpB,IAAI,GAAGyB,SAAX;EACA,GAAG;IAAA,IAAA,KAAA;;IACD;IACA,IAAIF,MAAM,IAAIC,KAAVD,IAAmBA,MAAM,GAAGC,KAATD,IAAkB,CAAzC,EAA4C,OAAOxC,WAAW,CAACgC,KAAnB;IAE5C,IAAIW,OAAO,GAAGV,UAAU,GAAGO,MAA3B;IAEA,IAAIpB,KAAK,GAAGrB,KAAK,CAAC6C,UAAlB,EAA8B;MAC5BD,OAAO,GAAG,CAACA,OAAO,GAAGF,KAAX,IAAoBA,KAA9BE;IACD,CAFD,MAEO;MACL,IAAIA,OAAO,GAAG,CAAd,EAAiB,OAAO3C,WAAW,CAAC6C,SAAnB;MACjB,IAAIF,OAAO,IAAIF,KAAf,EAAsB,OAAOzC,WAAW,CAAC8C,QAAnB;IACvB;IAED7B,IAAI,GAAGM,QAAQ,CAACoB,OAAD,CAAf1B,CAbC,CAAA;;IAgBD,CAAA,KAAA,GAAA,IAAI,KAAA,IAAJ,GAAA,KAAA,CAAA,GAAA,KAAA,CAAMG,KAAN,CAAYkB,YAAZ,CAAA,CAhBC,CAAA;;IAmBDE,MAAM,IAAIb,SAAVa;EACD,CApBD,QAoBSvB,IAAI,KAAKb,QAAQ,CAACsB,aApB3B,EAAA,CAAA;EAuBA;EACA;EACA;EACA;EACA;EACA;;EACA,IAAI,CAACT,IAAI,CAAC8B,YAAL9B,CAAkB,UAAlBA,CAAL,EAAoCA,IAAI,CAAC+B,YAAL/B,CAAkB,UAAlBA,EAA8B,GAA9BA,CAAAA;EAEpC,OAAOjB,WAAW,CAACiD,OAAnB;AACD","sourcesContent":["import { match } from './match'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        selector => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : selector => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === document.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: Focus) {\n  let elements = Array.isArray(container) ? container : getFocusableElements(container)\n  let active = document.activeElement as HTMLElement\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== document.activeElement)\n\n  // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0')\n\n  return FocusResult.Success\n}\n"]},"metadata":{},"sourceType":"module"}